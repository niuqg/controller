/*
* Generated file
*
* Generated from: yang module name: odl-sal-netconf-connector-cfg yang module local name: sal-netconf-connector
* Generated by: org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
* Generated at: Mon Jun 16 12:25:13 CST 2014
*
* Do not modify this file unless it is present under src/main directory
*/
package org.opendaylight.controller.config.yang.md.sal.connector.netconf;
@org.opendaylight.yangtools.yang.binding.annotations.ModuleQName(revision = "2013-10-28", name = "odl-sal-netconf-connector-cfg", namespace = "urn:opendaylight:params:xml:ns:yang:controller:md:sal:connector:netconf")

public abstract class AbstractNetconfConnectorModule implements org.opendaylight.controller.config.spi.Module,org.opendaylight.controller.config.yang.md.sal.connector.netconf.NetconfConnectorModuleMXBean {
    private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(org.opendaylight.controller.config.yang.md.sal.connector.netconf.AbstractNetconfConnectorModule.class);

    //attributes start

    public static final org.opendaylight.controller.config.api.JmxAttribute portJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("Port");
    private java.lang.Long port;

    public static final org.opendaylight.controller.config.api.JmxAttribute workerThreadGroupJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("WorkerThreadGroup");
    private javax.management.ObjectName workerThreadGroup; // optional

    public static final org.opendaylight.controller.config.api.JmxAttribute connectionTimeoutMillisJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("ConnectionTimeoutMillis");
    private java.lang.Long connectionTimeoutMillis = new java.lang.Long("20000");

    public static final org.opendaylight.controller.config.api.JmxAttribute betweenAttemptsTimeoutMillisJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("BetweenAttemptsTimeoutMillis");
    private java.lang.Integer betweenAttemptsTimeoutMillis = new java.lang.Integer("10000");

    public static final org.opendaylight.controller.config.api.JmxAttribute bossThreadGroupJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("BossThreadGroup");
    private javax.management.ObjectName bossThreadGroup; // optional

    public static final org.opendaylight.controller.config.api.JmxAttribute passwordJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("Password");
    private java.lang.String password;

    public static final org.opendaylight.controller.config.api.JmxAttribute domRegistryJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("DomRegistry");
    private javax.management.ObjectName domRegistry; // mandatory

    public static final org.opendaylight.controller.config.api.JmxAttribute clientDispatcherJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("ClientDispatcher");
    private javax.management.ObjectName clientDispatcher; // optional

    public static final org.opendaylight.controller.config.api.JmxAttribute usernameJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("Username");
    private java.lang.String username;

    public static final org.opendaylight.controller.config.api.JmxAttribute addressJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("Address");
    private java.lang.String address;

    public static final org.opendaylight.controller.config.api.JmxAttribute tcpOnlyJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("TcpOnly");
    private java.lang.Boolean tcpOnly;

    public static final org.opendaylight.controller.config.api.JmxAttribute maxConnectionAttemptsJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("MaxConnectionAttempts");
    private java.lang.Long maxConnectionAttempts = new java.lang.Long("0");

    public static final org.opendaylight.controller.config.api.JmxAttribute eventExecutorJmxAttribute = new org.opendaylight.controller.config.api.JmxAttribute("EventExecutor");
    private javax.management.ObjectName eventExecutor; // mandatory

    //attributes end

    private final AbstractNetconfConnectorModule oldModule;
    private final java.lang.AutoCloseable oldInstance;
    private java.lang.AutoCloseable instance;
    private final org.opendaylight.controller.config.api.DependencyResolver dependencyResolver;
    private final org.opendaylight.controller.config.api.ModuleIdentifier identifier;
    @Override
    public org.opendaylight.controller.config.api.ModuleIdentifier getIdentifier() {
        return identifier;
    }

    public AbstractNetconfConnectorModule(org.opendaylight.controller.config.api.ModuleIdentifier identifier,org.opendaylight.controller.config.api.DependencyResolver dependencyResolver) {
        this.identifier = identifier;
        this.dependencyResolver = dependencyResolver;
        this.oldInstance=null;
        ;this.oldModule=null;
    }

    public AbstractNetconfConnectorModule(org.opendaylight.controller.config.api.ModuleIdentifier identifier,org.opendaylight.controller.config.api.DependencyResolver dependencyResolver,AbstractNetconfConnectorModule oldModule,java.lang.AutoCloseable oldInstance) {
        this.identifier = identifier;
        this.dependencyResolver = dependencyResolver;
        this.oldModule = oldModule;
        this.oldInstance = oldInstance;
    }

    @Override
    public void validate() {
        dependencyResolver.validateDependency(org.opendaylight.controller.config.yang.md.sal.dom.BrokerServiceInterface.class, domRegistry, domRegistryJmxAttribute);dependencyResolver.validateDependency(org.opendaylight.controller.config.yang.netty.EventExecutorServiceInterface.class, eventExecutor, eventExecutorJmxAttribute);
        customValidation();
    }

    protected void customValidation() {
    }

    private io.netty.channel.EventLoopGroup workerThreadGroupDependency;
    protected final io.netty.channel.EventLoopGroup getWorkerThreadGroupDependency(){
        return workerThreadGroupDependency;
    }private io.netty.channel.EventLoopGroup bossThreadGroupDependency;
    protected final io.netty.channel.EventLoopGroup getBossThreadGroupDependency(){
        return bossThreadGroupDependency;
    }private org.opendaylight.controller.sal.core.api.Broker domRegistryDependency;
    protected final org.opendaylight.controller.sal.core.api.Broker getDomRegistryDependency(){
        return domRegistryDependency;
    }private org.opendaylight.controller.netconf.client.NetconfClientDispatcher clientDispatcherDependency;
    protected final org.opendaylight.controller.netconf.client.NetconfClientDispatcher getClientDispatcherDependency(){
        return clientDispatcherDependency;
    }private io.netty.util.concurrent.EventExecutor eventExecutorDependency;
    protected final io.netty.util.concurrent.EventExecutor getEventExecutorDependency(){
        return eventExecutorDependency;
    }

    @Override
    public final java.lang.AutoCloseable getInstance() {
        if(instance==null) {
            domRegistryDependency = dependencyResolver.resolveInstance(org.opendaylight.controller.sal.core.api.Broker.class, domRegistry, domRegistryJmxAttribute);eventExecutorDependency = dependencyResolver.resolveInstance(io.netty.util.concurrent.EventExecutor.class, eventExecutor, eventExecutorJmxAttribute);if (workerThreadGroup!=null) {
                workerThreadGroupDependency = dependencyResolver.resolveInstance(io.netty.channel.EventLoopGroup.class, workerThreadGroup, workerThreadGroupJmxAttribute);;
            }if (clientDispatcher!=null) {
                clientDispatcherDependency = dependencyResolver.resolveInstance(org.opendaylight.controller.netconf.client.NetconfClientDispatcher.class, clientDispatcher, clientDispatcherJmxAttribute);;
            }if (bossThreadGroup!=null) {
                bossThreadGroupDependency = dependencyResolver.resolveInstance(io.netty.channel.EventLoopGroup.class, bossThreadGroup, bossThreadGroupJmxAttribute);;
            }if(oldInstance!=null && canReuseInstance(oldModule)) {
                instance = reuseInstance(oldInstance);
            } else {
                if(oldInstance!=null) {
                    try {
                        oldInstance.close();
                    } catch(Exception e) {
                        logger.error("An error occurred while closing old instance " + oldInstance, e);
                    }
                }
                instance = createInstance();
                if (instance == null) {
                    throw new IllegalStateException("Error in createInstance - null is not allowed as return value");
                }
            }
        }
        return instance;
    }
    public abstract java.lang.AutoCloseable createInstance();

    public boolean canReuseInstance(AbstractNetconfConnectorModule oldModule){
        // allow reusing of old instance if no parameters was changed
        return isSame(oldModule);
    }

    public java.lang.AutoCloseable reuseInstance(java.lang.AutoCloseable oldInstance){
        // implement if instance reuse should be supported. Override canReuseInstance to change the criteria.
        return oldInstance;
    }

    public boolean isSame(AbstractNetconfConnectorModule other) {
        if (other == null) {
            throw new IllegalArgumentException("Parameter 'other' is null");
        }
        if (java.util.Objects.deepEquals(port, other.port) == false) {
            return false;
        }
        if (workerThreadGroupDependency != other.workerThreadGroupDependency) { // reference to dependency must be same
            return false;
        }
        if (java.util.Objects.deepEquals(connectionTimeoutMillis, other.connectionTimeoutMillis) == false) {
            return false;
        }
        if (java.util.Objects.deepEquals(betweenAttemptsTimeoutMillis, other.betweenAttemptsTimeoutMillis) == false) {
            return false;
        }
        if (bossThreadGroupDependency != other.bossThreadGroupDependency) { // reference to dependency must be same
            return false;
        }
        if (java.util.Objects.deepEquals(password, other.password) == false) {
            return false;
        }
        if (domRegistryDependency != other.domRegistryDependency) { // reference to dependency must be same
            return false;
        }
        if (clientDispatcherDependency != other.clientDispatcherDependency) { // reference to dependency must be same
            return false;
        }
        if (java.util.Objects.deepEquals(username, other.username) == false) {
            return false;
        }
        if (java.util.Objects.deepEquals(address, other.address) == false) {
            return false;
        }
        if (java.util.Objects.deepEquals(tcpOnly, other.tcpOnly) == false) {
            return false;
        }
        if (java.util.Objects.deepEquals(maxConnectionAttempts, other.maxConnectionAttempts) == false) {
            return false;
        }
        if (eventExecutorDependency != other.eventExecutorDependency) { // reference to dependency must be same
            return false;
        }

        return true;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        AbstractNetconfConnectorModule that = (AbstractNetconfConnectorModule) o;
        return identifier.equals(that.identifier);
    }

    @Override
    public int hashCode() {
        return identifier.hashCode();
    }

    // getters and setters
    @Override
    public java.lang.Long getPort() {
        return port;
    }

    @Override
    public void setPort(java.lang.Long port) {
        this.port = port;
    }

    @Override
    public javax.management.ObjectName getWorkerThreadGroup() {
        return workerThreadGroup;
    }

    @Override
    @org.opendaylight.controller.config.api.annotations.RequireInterface(value = org.opendaylight.controller.config.yang.netty.EventLoopGroupServiceInterface.class)
    public void setWorkerThreadGroup(javax.management.ObjectName workerThreadGroup) {
        this.workerThreadGroup = workerThreadGroup;
    }

    @Override
    public java.lang.Long getConnectionTimeoutMillis() {
        return connectionTimeoutMillis;
    }

    /**
    * Specifies timeout in milliseconds after which connection must be established.
    */
    @Override
    @org.opendaylight.controller.config.api.annotations.Description(value = "Specifies timeout in milliseconds after which connection must be established.")
    public void setConnectionTimeoutMillis(java.lang.Long connectionTimeoutMillis) {
        this.connectionTimeoutMillis = connectionTimeoutMillis;
    }

    @Override
    public java.lang.Integer getBetweenAttemptsTimeoutMillis() {
        return betweenAttemptsTimeoutMillis;
    }

    /**
    * Timeout in milliseconds to wait between connection attempts.
    */
    @Override
    @org.opendaylight.controller.config.api.annotations.Description(value = "Timeout in milliseconds to wait between connection attempts.")
    public void setBetweenAttemptsTimeoutMillis(java.lang.Integer betweenAttemptsTimeoutMillis) {
        this.betweenAttemptsTimeoutMillis = betweenAttemptsTimeoutMillis;
    }

    @Override
    public javax.management.ObjectName getBossThreadGroup() {
        return bossThreadGroup;
    }

    @Override
    @org.opendaylight.controller.config.api.annotations.RequireInterface(value = org.opendaylight.controller.config.yang.netty.EventLoopGroupServiceInterface.class)
    public void setBossThreadGroup(javax.management.ObjectName bossThreadGroup) {
        this.bossThreadGroup = bossThreadGroup;
    }

    @Override
    public java.lang.String getPassword() {
        return password;
    }

    @Override
    public void setPassword(java.lang.String password) {
        this.password = password;
    }

    @Override
    public javax.management.ObjectName getDomRegistry() {
        return domRegistry;
    }

    @Override
    @org.opendaylight.controller.config.api.annotations.RequireInterface(value = org.opendaylight.controller.config.yang.md.sal.dom.BrokerServiceInterface.class)
    public void setDomRegistry(javax.management.ObjectName domRegistry) {
        this.domRegistry = domRegistry;
    }

    @Override
    public javax.management.ObjectName getClientDispatcher() {
        return clientDispatcher;
    }

    @Override
    @org.opendaylight.controller.config.api.annotations.RequireInterface(value = org.opendaylight.controller.config.yang.config.netconf.NetconfClientDispatcherServiceInterface.class)
    public void setClientDispatcher(javax.management.ObjectName clientDispatcher) {
        this.clientDispatcher = clientDispatcher;
    }

    @Override
    public java.lang.String getUsername() {
        return username;
    }

    @Override
    public void setUsername(java.lang.String username) {
        this.username = username;
    }

    @Override
    public java.lang.String getAddress() {
        return address;
    }

    @Override
    public void setAddress(java.lang.String address) {
        this.address = address;
    }

    @Override
    public java.lang.Boolean getTcpOnly() {
        return tcpOnly;
    }

    @Override
    public void setTcpOnly(java.lang.Boolean tcpOnly) {
        this.tcpOnly = tcpOnly;
    }

    @Override
    public java.lang.Long getMaxConnectionAttempts() {
        return maxConnectionAttempts;
    }

    /**
    * Maximum number of connection retries. Non positive value or null is interpreted as infinity.
    */
    @Override
    @org.opendaylight.controller.config.api.annotations.Description(value = "Maximum number of connection retries. Non positive value or null is interpreted as infinity.")
    public void setMaxConnectionAttempts(java.lang.Long maxConnectionAttempts) {
        this.maxConnectionAttempts = maxConnectionAttempts;
    }

    @Override
    public javax.management.ObjectName getEventExecutor() {
        return eventExecutor;
    }

    @Override
    @org.opendaylight.controller.config.api.annotations.RequireInterface(value = org.opendaylight.controller.config.yang.netty.EventExecutorServiceInterface.class)
    public void setEventExecutor(javax.management.ObjectName eventExecutor) {
        this.eventExecutor = eventExecutor;
    }

}
